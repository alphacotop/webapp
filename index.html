<script>
    const ui = {
        video: document.getElementById('video'),
        canvas: document.getElementById('canvas'),
        loader: document.getElementById('loader'),
        loadingText: document.getElementById('loading-text'),
        nameInput: document.getElementById('name-input'),
        registerBtn: document.getElementById('register-btn'),
        clearBtn: document.getElementById('clear-btn'),
        registeredUsersList: document.getElementById('registered-users-list'),
        resultDisplay: document.getElementById('result-display'),
        connectSerialBtn: document.getElementById('connectSerialBtn'),
        disconnectSerialBtn: document.getElementById('disconnectSerialBtn'),
        connectBleBtn: document.getElementById('connectBleBtn'),
        disconnectBleBtn: document.getElementById('disconnectBleBtn'),
        connectionStatus: document.getElementById('connectionStatus'),
        bleDeviceType: document.getElementById('ble-device-type')
    };

    const CONFIG = {
        SERIAL_BAUD_RATE: 9600,
        BLE_SERVICE_UUID: '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
        BLE_CHARACTERISTIC_UUID: '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
        RECOGNITION_THRESHOLD: 0.4, 
        MAX_USERS: 5,
        LOCAL_STORAGE_KEY: 'faceLockRegisteredUsers'
    };

    const ConnectionManager = {
        port: null, writer: null,
        bleDevice: null, bleCharacteristic: null,
        
        async sendToMCU(data) {
            const dataToSend = data + '\n';
            if (this.port?.writable) {
                try {
                    this.writer = this.port.writable.getWriter();
                    await this.writer.write(new TextEncoder().encode(dataToSend));
                } catch (e) { console.error("ì‹œë¦¬ì–¼ ë°ì´í„° ì „ì†¡ ì˜¤ë¥˜:", e); } 
                finally { if (this.writer) { this.writer.releaseLock(); this.writer = null; } }
            }
            if (this.bleCharacteristic) {
                try { await this.bleCharacteristic.writeValue(new TextEncoder().encode(dataToSend)); } 
                catch (e) { console.error("BLE ë°ì´í„° ì „ì†¡ ì˜¤ë¥˜:", e); }
            }
        },
        
        async connectSerial() { 
            try {
                const port = await navigator.serial.requestPort(); 
                await port.open({ baudRate: CONFIG.SERIAL_BAUD_RATE }); 
                this.port = port;
                this.updateConnectionStatus(true, 'ì‹œë¦¬ì–¼');
            } catch(e) {
                if (e.name !== 'NotFoundError') alert(`ì‹œë¦¬ì–¼ ì—°ê²° ì˜¤ë¥˜: ${e.message}`);
            } 
        },

        async disconnectSerial() { 
            if (!this.port) return;
            try { if (this.port.readable || this.port.writable) await this.port.close(); } 
            catch (e) { console.error('í¬íŠ¸ ë‹«ê¸° ì¤‘ ì˜¤ë¥˜:', e); } 
            finally { this.port = null; this.updateConnectionStatus(false); }
        },

        async connectBLE() {
            const devType = ui.bleDeviceType.value;
            const opts = devType === 'microbit' ? {filters:[{namePrefix:"BBC micro:bit"}], optionalServices:[CONFIG.BLE_SERVICE_UUID]} : {filters:[{services:[CONFIG.BLE_SERVICE_UUID]}]};
            try {
                this.bleDevice = await navigator.bluetooth.requestDevice(opts);
                this.bleDevice.addEventListener('gattserverdisconnected', () => this.updateConnectionStatus(false));
                const server = await this.bleDevice.gatt.connect();
                const service = await server.getPrimaryService(CONFIG.BLE_SERVICE_UUID);
                this.bleCharacteristic = await service.getCharacteristic(CONFIG.BLE_CHARACTERISTIC_UUID);
                this.updateConnectionStatus(true, 'ë¸”ë£¨íˆ¬ìŠ¤'); 
                alert('ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì„±ê³µ!');
            } catch(e) {
                alert(`ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì˜¤ë¥˜: ${e.message}`); 
                this.updateConnectionStatus(false);
            }
        },

        disconnectBLE() { 
            if(this.bleDevice?.gatt.connected){
                this.bleDevice.gatt.disconnect();
            } 
        },

        updateConnectionStatus(connected, type = '') {
            ui.connectionStatus.textContent = connected ? `${type} ì—°ê²°ë¨` : 'ì—°ê²° ì•ˆë¨';
            ui.connectionStatus.className = `status ${connected ? 'connected' : 'disconnected'}`;
            if (type.toLowerCase().includes('serial') || type.toLowerCase().includes('ì‹œë¦¬ì–¼')) {
                ui.connectSerialBtn.disabled = connected;
                ui.disconnectSerialBtn.disabled = !connected;
            }
        }
    };


    const FaceLockApp = {
        registeredUsers: [],
        faceMatcher: null,
        modelsLoaded: false, 

        async init() {
            this.setupEventListeners();
            this.startWebcam();
            await this.loadModels();
            this.loadRegisteredFaces();
        },

        setupEventListeners() {
            ui.registerBtn.addEventListener('click', () => this.handleRegistration());
            ui.clearBtn.addEventListener('click', () => this.handleClear());
            ui.connectSerialBtn.addEventListener('click', () => ConnectionManager.connectSerial());
            ui.disconnectSerialBtn.addEventListener('click', () => ConnectionManager.disconnectSerial());
            ui.connectBleBtn.addEventListener('click', () => ConnectionManager.connectBLE());
            ui.disconnectBleBtn.addEventListener('click', () => ConnectionManager.disconnectBLE());
        },

        async loadModels() {
            const MODEL_URL = './weights'; 
            try {
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
                ]);
                this.modelsLoaded = true;
                ui.loader.style.display = 'none';
                ui.loadingText.style.display = 'none';
            } catch (error) {
                ui.loader.style.display = 'none';
                ui.loadingText.innerHTML = "ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨.<br>'weights' í´ë”ê°€ html íŒŒì¼ ì˜†ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.";
                console.error("AI ëª¨ë¸ ë¡œë”© ì˜¤ë¥˜:", error);
            }
        },

        startWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                .then(stream => {
                    ui.video.srcObject = stream;
                    ui.video.addEventListener('play', () => this.startRecognitionLoop());
                })
                .catch(err => {
                    alert("ì›¹ìº ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
                    ui.loader.style.display = 'none';
                    ui.loadingText.textContent = "ì¹´ë©”ë¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.";
                });
        },

        loadRegisteredFaces() {
            const data = localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY);
            if (data) {
                const parsedData = JSON.parse(data);
                this.registeredUsers = parsedData.map(user => 
                    new faceapi.LabeledFaceDescriptors(user.label, user.descriptors.map(d => new Float32Array(d)))
                );
            }
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();
        },

        saveRegisteredFaces() {
            const dataToSave = this.registeredUsers.map(user => ({
                label: user.label,
                descriptors: user.descriptors.map(d => Array.from(d))
            }));
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
        },
        
        updateRegisteredUsersUI() {
            ui.registeredUsersList.innerHTML = '';
            this.registeredUsers.forEach(user => {
                const userEl = document.createElement('div');
                userEl.className = 'user-list-item';
                // *** ì—¬ê¸°ê°€ ìˆ˜ì •ëœ ë¶€ë¶„: ë“±ë¡ íšŸìˆ˜ í‘œì‹œ ***
                userEl.innerHTML = `<span>ğŸ‘¤ ${user.label} (${user.descriptors.length}íšŒ ë“±ë¡)</span><button data-label="${user.label}">&times;</button>`;
                ui.registeredUsersList.appendChild(userEl);
            });
            ui.registeredUsersList.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', (e) => this.removeUser(e.target.dataset.label));
            });
        },

        async handleRegistration() {
            if (!this.modelsLoaded) {
                alert("ì•„ì§ AI ëª¨ë¸ì´ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.");
                return;
            }
            const name = ui.nameInput.value.trim();
            if (!name) {
                alert("ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }

            ui.resultDisplay.textContent = 'ì–¼êµ´ì„ ì •ë©´ìœ¼ë¡œ ë³´ì—¬ì£¼ì„¸ìš”...';
            const detections = await faceapi.detectSingleFace(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();

            if (!detections) {
                alert("ì–¼êµ´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì€ ê³³ì—ì„œ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
                ui.resultDisplay.textContent = '';
                return;
            }

            // *** ì—¬ê¸°ê°€ í•µì‹¬ ìˆ˜ì • ë¶€ë¶„: ê¸°ì¡´ ì‚¬ìš©ìì¸ì§€ í™•ì¸í•˜ê³ , ì–¼êµ´ íŠ¹ì§•ì„ ì¶”ê°€í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„± ***
            const existingUser = this.registeredUsers.find(user => user.label === name);

            if (existingUser) {
                // ì´ë¯¸ ë“±ë¡ëœ ì´ë¦„ì´ë©´, ìƒˆë¡œìš´ ì–¼êµ´ íŠ¹ì§•(descriptor)ë§Œ ì¶”ê°€
                existingUser.descriptors.push(detections.descriptor);
                ui.resultDisplay.textContent = `${name}ë‹˜ì˜ ìƒˆë¡œìš´ ì–¼êµ´ ì •ë³´ ì¶”ê°€ ì™„ë£Œ!`;

            } else {
                // ìƒˆë¡œìš´ ì´ë¦„ì´ë©´, ìµœëŒ€ ì‚¬ìš©ì ìˆ˜ ì²´í¬ í›„ ì‹ ê·œ ë“±ë¡
                if (this.registeredUsers.length >= CONFIG.MAX_USERS) {
                    alert(`ìµœëŒ€ ${CONFIG.MAX_USERS}ëª…ê¹Œì§€ë§Œ ë“±ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
                    return;
                }
                const newDescriptor = new faceapi.LabeledFaceDescriptors(name, [detections.descriptor]);
                this.registeredUsers.push(newDescriptor);
                ui.resultDisplay.textContent = `${name}ë‹˜ ì‹ ê·œ ë“±ë¡ ì™„ë£Œ!`;
            }
            
            this.saveRegisteredFaces();
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();

            ui.nameInput.value = '';
            setTimeout(() => ui.resultDisplay.textContent = '', 2000);
        },
        
        removeUser(labelToRemove) {
            this.registeredUsers = this.registeredUsers.filter(user => user.label !== labelToRemove);
            this.saveRegisteredFaces();
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();
        },

        handleClear() {
            if(confirm("ì •ë§ë¡œ ëª¨ë“  ë“±ë¡ëœ ì–¼êµ´ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                this.registeredUsers = [];
                localStorage.removeItem(CONFIG.LOCAL_STORAGE_KEY);
                this.updateFaceMatcher();
                this.updateRegisteredUsersUI();
            }
        },
        
        updateFaceMatcher() {
            if (this.registeredUsers.length > 0) {
                this.faceMatcher = new faceapi.FaceMatcher(this.registeredUsers, CONFIG.RECOGNITION_THRESHOLD);
            } else {
                this.faceMatcher = null;
            }
        },

        startRecognitionLoop() {
            const displaySize = { width: ui.video.clientWidth, height: ui.video.clientHeight };
            faceapi.matchDimensions(ui.canvas, displaySize);

            setInterval(async () => {
                if (!this.modelsLoaded) {
                    return;
                }

                const detections = await faceapi.detectAllFaces(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();
                const resizedDetections = faceapi.resizeResults(detections, displaySize);
                
                ui.canvas.getContext('2d').clearRect(0, 0, ui.canvas.width, ui.canvas.height);
                
                if (!this.faceMatcher) {
                    ui.resultDisplay.textContent = "ì–¼êµ´ì„ ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”.";
                    return;
                }

                if (resizedDetections.length > 0) {
                    const results = resizedDetections.map(d => this.faceMatcher.findBestMatch(d.descriptor));
                    
                    let recognized = false;
                    results.forEach((result, i) => {
                        const box = resizedDetections[i].detection.box;
                        const drawBox = new faceapi.draw.DrawBox(box, { label: result.toString() });
                        drawBox.draw(ui.canvas);

                        if (result.label !== 'unknown') {
                            ui.resultDisplay.innerHTML = `âœ… <span style="color:var(--primary)">${result.label}</span>ë‹˜, ì¸ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                            ConnectionManager.sendToMCU('1');
                            recognized = true;
                        }
                    });

                    if (!recognized) {
                       ui.resultDisplay.innerHTML = 'âŒ ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.';
                       ConnectionManager.sendToMCU('0');
                    }
                } else {
                    ui.resultDisplay.textContent = 'ì¹´ë©”ë¼ ì•ì—ì„œ ì–¼êµ´ì„ ë³´ì—¬ì£¼ì„¸ìš”.';
                }
            }, 200);
        }
    };

    document.addEventListener('DOMContentLoaded', () => FaceLockApp.init());
</script>