<script>
    const ui = {
        video: document.getElementById('video'),
        canvas: document.getElementById('canvas'),
        loader: document.getElementById('loader'),
        loadingText: document.getElementById('loading-text'),
        nameInput: document.getElementById('name-input'),
        registerBtn: document.getElementById('register-btn'),
        clearBtn: document.getElementById('clear-btn'),
        registeredUsersList: document.getElementById('registered-users-list'),
        resultDisplay: document.getElementById('result-display'),
        connectSerialBtn: document.getElementById('connectSerialBtn'),
        disconnectSerialBtn: document.getElementById('disconnectSerialBtn'),
        connectBleBtn: document.getElementById('connectBleBtn'),
        disconnectBleBtn: document.getElementById('disconnectBleBtn'),
        connectionStatus: document.getElementById('connectionStatus'),
        bleDeviceType: document.getElementById('ble-device-type')
    };

    const CONFIG = {
        SERIAL_BAUD_RATE: 9600,
        BLE_SERVICE_UUID: '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
        BLE_CHARACTERISTIC_UUID: '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
        RECOGNITION_THRESHOLD: 0.4, 
        MAX_USERS: 5,
        LOCAL_STORAGE_KEY: 'faceLockRegisteredUsers'
    };

    const ConnectionManager = {
        port: null, writer: null,
        bleDevice: null, bleCharacteristic: null,
        
        async sendToMCU(data) {
            const dataToSend = data + '\n';
            if (this.port?.writable) {
                try {
                    this.writer = this.port.writable.getWriter();
                    await this.writer.write(new TextEncoder().encode(dataToSend));
                } catch (e) { console.error("시리얼 데이터 전송 오류:", e); } 
                finally { if (this.writer) { this.writer.releaseLock(); this.writer = null; } }
            }
            if (this.bleCharacteristic) {
                try { await this.bleCharacteristic.writeValue(new TextEncoder().encode(dataToSend)); } 
                catch (e) { console.error("BLE 데이터 전송 오류:", e); }
            }
        },
        
        async connectSerial() { 
            try {
                const port = await navigator.serial.requestPort(); 
                await port.open({ baudRate: CONFIG.SERIAL_BAUD_RATE }); 
                this.port = port;
                this.updateConnectionStatus(true, '시리얼');
            } catch(e) {
                if (e.name !== 'NotFoundError') alert(`시리얼 연결 오류: ${e.message}`);
            } 
        },

        async disconnectSerial() { 
            if (!this.port) return;
            try { if (this.port.readable || this.port.writable) await this.port.close(); } 
            catch (e) { console.error('포트 닫기 중 오류:', e); } 
            finally { this.port = null; this.updateConnectionStatus(false); }
        },

        async connectBLE() {
            const devType = ui.bleDeviceType.value;
            const opts = devType === 'microbit' ? {filters:[{namePrefix:"BBC micro:bit"}], optionalServices:[CONFIG.BLE_SERVICE_UUID]} : {filters:[{services:[CONFIG.BLE_SERVICE_UUID]}]};
            try {
                this.bleDevice = await navigator.bluetooth.requestDevice(opts);
                this.bleDevice.addEventListener('gattserverdisconnected', () => this.updateConnectionStatus(false));
                const server = await this.bleDevice.gatt.connect();
                const service = await server.getPrimaryService(CONFIG.BLE_SERVICE_UUID);
                this.bleCharacteristic = await service.getCharacteristic(CONFIG.BLE_CHARACTERISTIC_UUID);
                this.updateConnectionStatus(true, '블루투스'); 
                alert('블루투스 연결 성공!');
            } catch(e) {
                alert(`블루투스 연결 오류: ${e.message}`); 
                this.updateConnectionStatus(false);
            }
        },

        disconnectBLE() { 
            if(this.bleDevice?.gatt.connected){
                this.bleDevice.gatt.disconnect();
            } 
        },

        updateConnectionStatus(connected, type = '') {
            ui.connectionStatus.textContent = connected ? `${type} 연결됨` : '연결 안됨';
            ui.connectionStatus.className = `status ${connected ? 'connected' : 'disconnected'}`;
            if (type.toLowerCase().includes('serial') || type.toLowerCase().includes('시리얼')) {
                ui.connectSerialBtn.disabled = connected;
                ui.disconnectSerialBtn.disabled = !connected;
            }
        }
    };


    const FaceLockApp = {
        registeredUsers: [],
        faceMatcher: null,
        modelsLoaded: false, 

        async init() {
            this.setupEventListeners();
            this.startWebcam();
            await this.loadModels();
            this.loadRegisteredFaces();
        },

        setupEventListeners() {
            ui.registerBtn.addEventListener('click', () => this.handleRegistration());
            ui.clearBtn.addEventListener('click', () => this.handleClear());
            ui.connectSerialBtn.addEventListener('click', () => ConnectionManager.connectSerial());
            ui.disconnectSerialBtn.addEventListener('click', () => ConnectionManager.disconnectSerial());
            ui.connectBleBtn.addEventListener('click', () => ConnectionManager.connectBLE());
            ui.disconnectBleBtn.addEventListener('click', () => ConnectionManager.disconnectBLE());
        },

        async loadModels() {
            const MODEL_URL = './weights'; 
            try {
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
                ]);
                this.modelsLoaded = true;
                ui.loader.style.display = 'none';
                ui.loadingText.style.display = 'none';
            } catch (error) {
                ui.loader.style.display = 'none';
                ui.loadingText.innerHTML = "모델 로딩 실패.<br>'weights' 폴더가 html 파일 옆에 있는지 확인하세요.";
                console.error("AI 모델 로딩 오류:", error);
            }
        },

        startWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                .then(stream => {
                    ui.video.srcObject = stream;
                    ui.video.addEventListener('play', () => this.startRecognitionLoop());
                })
                .catch(err => {
                    alert("웹캠을 시작할 수 없습니다. 카메라 권한을 확인해주세요.");
                    ui.loader.style.display = 'none';
                    ui.loadingText.textContent = "카메라 권한이 필요합니다.";
                });
        },

        loadRegisteredFaces() {
            const data = localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY);
            if (data) {
                const parsedData = JSON.parse(data);
                this.registeredUsers = parsedData.map(user => 
                    new faceapi.LabeledFaceDescriptors(user.label, user.descriptors.map(d => new Float32Array(d)))
                );
            }
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();
        },

        saveRegisteredFaces() {
            const dataToSave = this.registeredUsers.map(user => ({
                label: user.label,
                descriptors: user.descriptors.map(d => Array.from(d))
            }));
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
        },
        
        updateRegisteredUsersUI() {
            ui.registeredUsersList.innerHTML = '';
            this.registeredUsers.forEach(user => {
                const userEl = document.createElement('div');
                userEl.className = 'user-list-item';
                // *** 여기가 수정된 부분: 등록 횟수 표시 ***
                userEl.innerHTML = `<span>👤 ${user.label} (${user.descriptors.length}회 등록)</span><button data-label="${user.label}">&times;</button>`;
                ui.registeredUsersList.appendChild(userEl);
            });
            ui.registeredUsersList.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', (e) => this.removeUser(e.target.dataset.label));
            });
        },

        async handleRegistration() {
            if (!this.modelsLoaded) {
                alert("아직 AI 모델이 로딩 중입니다. 잠시만 기다려주세요.");
                return;
            }
            const name = ui.nameInput.value.trim();
            if (!name) {
                alert("이름을 입력해주세요.");
                return;
            }

            ui.resultDisplay.textContent = '얼굴을 정면으로 보여주세요...';
            const detections = await faceapi.detectSingleFace(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();

            if (!detections) {
                alert("얼굴을 찾을 수 없습니다. 밝은 곳에서 다시 시도해주세요.");
                ui.resultDisplay.textContent = '';
                return;
            }

            // *** 여기가 핵심 수정 부분: 기존 사용자인지 확인하고, 얼굴 특징을 추가하거나 새로 생성 ***
            const existingUser = this.registeredUsers.find(user => user.label === name);

            if (existingUser) {
                // 이미 등록된 이름이면, 새로운 얼굴 특징(descriptor)만 추가
                existingUser.descriptors.push(detections.descriptor);
                ui.resultDisplay.textContent = `${name}님의 새로운 얼굴 정보 추가 완료!`;

            } else {
                // 새로운 이름이면, 최대 사용자 수 체크 후 신규 등록
                if (this.registeredUsers.length >= CONFIG.MAX_USERS) {
                    alert(`최대 ${CONFIG.MAX_USERS}명까지만 등록할 수 있습니다.`);
                    return;
                }
                const newDescriptor = new faceapi.LabeledFaceDescriptors(name, [detections.descriptor]);
                this.registeredUsers.push(newDescriptor);
                ui.resultDisplay.textContent = `${name}님 신규 등록 완료!`;
            }
            
            this.saveRegisteredFaces();
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();

            ui.nameInput.value = '';
            setTimeout(() => ui.resultDisplay.textContent = '', 2000);
        },
        
        removeUser(labelToRemove) {
            this.registeredUsers = this.registeredUsers.filter(user => user.label !== labelToRemove);
            this.saveRegisteredFaces();
            this.updateFaceMatcher();
            this.updateRegisteredUsersUI();
        },

        handleClear() {
            if(confirm("정말로 모든 등록된 얼굴을 삭제하시겠습니까?")) {
                this.registeredUsers = [];
                localStorage.removeItem(CONFIG.LOCAL_STORAGE_KEY);
                this.updateFaceMatcher();
                this.updateRegisteredUsersUI();
            }
        },
        
        updateFaceMatcher() {
            if (this.registeredUsers.length > 0) {
                this.faceMatcher = new faceapi.FaceMatcher(this.registeredUsers, CONFIG.RECOGNITION_THRESHOLD);
            } else {
                this.faceMatcher = null;
            }
        },

        startRecognitionLoop() {
            const displaySize = { width: ui.video.clientWidth, height: ui.video.clientHeight };
            faceapi.matchDimensions(ui.canvas, displaySize);

            setInterval(async () => {
                if (!this.modelsLoaded) {
                    return;
                }

                const detections = await faceapi.detectAllFaces(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();
                const resizedDetections = faceapi.resizeResults(detections, displaySize);
                
                ui.canvas.getContext('2d').clearRect(0, 0, ui.canvas.width, ui.canvas.height);
                
                if (!this.faceMatcher) {
                    ui.resultDisplay.textContent = "얼굴을 먼저 등록해주세요.";
                    return;
                }

                if (resizedDetections.length > 0) {
                    const results = resizedDetections.map(d => this.faceMatcher.findBestMatch(d.descriptor));
                    
                    let recognized = false;
                    results.forEach((result, i) => {
                        const box = resizedDetections[i].detection.box;
                        const drawBox = new faceapi.draw.DrawBox(box, { label: result.toString() });
                        drawBox.draw(ui.canvas);

                        if (result.label !== 'unknown') {
                            ui.resultDisplay.innerHTML = `✅ <span style="color:var(--primary)">${result.label}</span>님, 인증되었습니다.`;
                            ConnectionManager.sendToMCU('1');
                            recognized = true;
                        }
                    });

                    if (!recognized) {
                       ui.resultDisplay.innerHTML = '❌ 등록되지 않은 사용자입니다.';
                       ConnectionManager.sendToMCU('0');
                    }
                } else {
                    ui.resultDisplay.textContent = '카메라 앞에서 얼굴을 보여주세요.';
                }
            }, 200);
        }
    };

    document.addEventListener('DOMContentLoaded', () => FaceLockApp.init());
</script>